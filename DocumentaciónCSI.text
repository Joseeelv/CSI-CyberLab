# CSI-CyberLab

## Portada

**Nombre del Proyecto:** CSI-CyberLab  
**Autor:** JosÃ©  
**Fecha:** 12 de Diciembre de 2025  

---

## IntroducciÃ³n

### MotivaciÃ³n
La ciberseguridad es un campo en constante crecimiento y evoluciÃ³n, con una demanda creciente de profesionales capacitados. CSI-CyberLab surge como una soluciÃ³n educativa para proporcionar un entorno prÃ¡ctico y seguro donde los estudiantes puedan desarrollar habilidades crÃ­ticas en ciberseguridad.

### Alcance
El proyecto abarca el desarrollo de una plataforma educativa full-stack que permite a los usuarios:
- Registrarse e iniciar sesiÃ³n de manera segura.
- Acceder a laboratorios prÃ¡cticos de ciberseguridad.
- Gestionar contenedores Docker asociados a los laboratorios.
- Realizar desafÃ­os y capturar flags para evaluar sus conocimientos.

### Objetivos Generales
- DiseÃ±ar e implementar una plataforma educativa interactiva y funcional.
- Proporcionar un entorno seguro para la prÃ¡ctica de ciberseguridad.
- Facilitar la gestiÃ³n de laboratorios y contenedores Docker.

### Objetivos EspecÃ­ficos
- Implementar un sistema de autenticaciÃ³n y autorizaciÃ³n robusto.
- Crear una interfaz de usuario intuitiva y fluida.
- DiseÃ±ar un backend eficiente con integraciÃ³n de bases de datos y contenedores Docker.
- Asegurar la persistencia de datos y el seguimiento del progreso de los usuarios.

### Contexto del Proyecto
El proyecto se desarrolla en el marco de una asignatura universitaria, con el objetivo de aplicar conocimientos teÃ³ricos en un entorno prÃ¡ctico. CSI-CyberLab utiliza tecnologÃ­as modernas como NestJS, Next.js, Docker y PostgreSQL para garantizar un sistema escalable y eficiente.

---

## AnÃ¡lisis

### Actores

1. **Estudiante:** Usuario principal que accede a los laboratorios, resuelve desafÃ­os y captura flags.
2. **Profesor:** Usuario que crea y gestiona laboratorios, supervisa el progreso de los estudiantes.
3. **Administrador:** Usuario con permisos para gestionar usuarios, categorÃ­as, dificultades y otros aspectos del sistema.
4. **Sistema:** Responsable de gestionar la autenticaciÃ³n, la persistencia de datos y la interacciÃ³n con Docker.

### Diagrama de Casos de Uso

```mermaid
usecaseDiagram
    actor Estudiante
    actor Profesor
    actor Administrador

    Estudiante --> (Registrarse)
    Estudiante --> (Iniciar SesiÃ³n)
    Estudiante --> (Acceder a Laboratorios)
    Estudiante --> (Resolver DesafÃ­os)
    Estudiante --> (Capturar Flags)

    Profesor --> (Crear Laboratorios)
    Profesor --> (Gestionar DesafÃ­os)
    Profesor --> (Supervisar Progreso)

    Administrador --> (Gestionar Usuarios)
    Administrador --> (Gestionar CategorÃ­as)
    Administrador --> (Gestionar Dificultades)
    Administrador --> (Monitorear Contenedores)
```

### Modelo Conceptual

El modelo conceptual incluye las entidades principales del sistema y sus relaciones. Estas entidades incluyen usuarios, laboratorios, contenedores, desafÃ­os y flags. El diagrama entidad-relaciÃ³n ya incluido en la documentaciÃ³n representa este modelo de manera detallada.

---

## Conclusiones

### Logros
- Se ha diseÃ±ado e implementado una plataforma educativa funcional y escalable.
- El sistema permite a los estudiantes practicar ciberseguridad en un entorno seguro y controlado.
- La integraciÃ³n de tecnologÃ­as modernas garantiza un rendimiento Ã³ptimo y una experiencia de usuario fluida.

### Retos
- La gestiÃ³n de contenedores Docker en tiempo real presentÃ³ desafÃ­os tÃ©cnicos significativos.
- La implementaciÃ³n de un sistema de seguimiento de progreso requiriÃ³ un diseÃ±o cuidadoso de las relaciones entre entidades.

### Futuras Mejoras
- Ampliar el sistema de notificaciones para incluir recordatorios y alertas personalizadas.
- Implementar un sistema de gamificaciÃ³n para motivar a los estudiantes.
- Optimizar el rendimiento del backend mediante el uso de cachÃ© y consultas mÃ¡s eficientes.

---

# DocumentaciÃ³n CSI-CyberLab

## Ãndice

1. [DescripciÃ³n General del Sistema](#descripciÃ³n-general-del-sistema)
2. [Modelo de Datos y Entidades](#modelo-de-datos-y-entidades)
3. [Diagrama Entidad-RelaciÃ³n](#diagrama-entidad-relaciÃ³n)
4. [AnÃ¡lisis de Relaciones](#anÃ¡lisis-de-relaciones)
5. [Casos de Uso](#casos-de-uso)
6. [Diagramas UML](#diagramas-uml)
7. [Recomendaciones y Mejoras](#recomendaciones-y-mejoras)

---

## DescripciÃ³n General del Sistema

**CSI-CyberLab** es una plataforma educativa de ciberseguridad que permite a usuarios (estudiantes, profesores y administradores) trabajar con laboratorios prÃ¡cticos mediante contenedores Docker. El sistema gestiona:

- CreaciÃ³n y gestiÃ³n de laboratorios de ciberseguridad
- Despliegue dinÃ¡mico de contenedores Docker
- AutenticaciÃ³n y autorizaciÃ³n de usuarios
- CategorizaciÃ³n de laboratorios por dificultad, sistema operativo y categorÃ­as
- Seguimiento del estado de laboratorios y contenedores

---

## Modelo de Datos y Entidades

### 1. **User (Usuario)**

Representa a los usuarios del sistema (estudiantes, profesores, administradores).

**Atributos:**

- `id`: number (PK)
- `fullName`: string (nullable)
- `username`: string
- `email`: string
- `password`: string (hash)
- `role`: string âš ï¸ **DEBERÃA SER UNA RELACIÃ“N con Role**
- `created`: timestamp
- `updated`: timestamp

**Relaciones:**

- `ManyToMany` con `Container` (usuarios pueden tener mÃºltiples contenedores activos)
- `ManyToMany` con `Lab` (usuarios pueden estar inscritos en mÃºltiples laboratorios)

---

### 2. **Role (Rol)**

Define los roles del sistema (admin, student, teacher).

**Atributos:**

- `id`: number (PK)
- `name`: string (unique)

**Relaciones:**

- âš ï¸ **NO TIENE relaciones definidas** - DeberÃ­a relacionarse con `User`

---

### 3. **Lab (Laboratorio)**

Representa los laboratorios prÃ¡cticos de ciberseguridad.

**Atributos:**

- `uuid`: string (PK, UUID)
- `name`: string
- `description`: string
- `points`: float (puntuaciÃ³n del laboratorio)
- `estimatedTime`: int (tiempo estimado en minutos)
- `tags`: string[] (array de etiquetas)
- `created`: timestamp
- `updated`: timestamp

**Relaciones:**

- `ManyToOne` con `Status` (estado del laboratorio)
- `ManyToMany` con `Category` (puede pertenecer a mÃºltiples categorÃ­as)
- `ManyToOne` con `Difficulty` (nivel de dificultad)
- `ManyToOne` con `OperatingSystem` (sistema operativo del laboratorio)
- `OneToMany` con `Container` (un laboratorio puede tener mÃºltiples instancias de contenedores)
- `ManyToMany` con `User` (mÃºltiples usuarios pueden estar inscritos)

---

### 4. **Container (Contenedor)**

Representa instancias de contenedores Docker asociados a laboratorios y usuarios.

**Atributos:**

- `id`: number (PK)
- `name`: string
- `created`: timestamp
- `lastActivity`: timestamp

**Relaciones:**

- `ManyToOne` con `Image` (imagen Docker utilizada)
- `ManyToOne` con `Lab` (laboratorio al que pertenece, con `onDelete: CASCADE`)
- `ManyToOne` con `Status` (estado del contenedor: running, stopped, etc.)
- `ManyToOne` con `User` (usuario propietario del contenedor)

---

### 5. **Image (Imagen Docker)**

Representa las imÃ¡genes Docker disponibles para crear contenedores.

**Atributos:**

- `id`: string (PK, UUID)
- `name`: string
- `version`: string (nullable)
- `repository`: string (nullable)
- `created`: timestamp
- `updated`: timestamp

**Relaciones:**

- âš ï¸ **RELACIÃ“N MAL DEFINIDA**: `OneToMany` con `OperatingSystem` (deberÃ­a ser `ManyToOne`)
- `OneToMany` con `Container` (una imagen puede usarse para mÃºltiples contenedores)
- `ManyToOne` con `OperatingSystem` como `baseOperatingSystem` (sistema operativo base)

---

### 6. **OperatingSystem (Sistema Operativo)**

CatÃ¡logo de sistemas operativos disponibles (Linux, Windows, etc.).

**Atributos:**

- `id`: number (PK)
- `name`: string
- `created`: timestamp
- `updated`: timestamp

**Relaciones:**

- `OneToMany` con `Lab` (laboratorios que usan este SO)
- `OneToMany` con `Image` (imÃ¡genes basadas en este SO)

---

### 7. **Category (CategorÃ­a)**

ClasificaciÃ³n temÃ¡tica de laboratorios (Web Security, Network Security, Cryptography, etc.).

**Atributos:**

- `id`: number (PK)
- `name`: string

**Relaciones:**

- âš ï¸ **RELACIÃ“N MAL DEFINIDA**: `OneToMany` con `Lab` (deberÃ­a ser `ManyToMany` ya que en Lab se define `ManyToMany`)

---

### 8. **Difficulty (Dificultad)**

Nivel de dificultad de los laboratorios (Beginner, Intermediate, Advanced, Expert).

**Atributos:**

- `id`: number (PK)
- `name`: string

**Relaciones:**

- `OneToMany` con `Lab`

---

### 9. **Status (Estado)**

Estados posibles para laboratorios y contenedores (Active, Inactive, Running, Stopped, Completed, etc.).

**Atributos:**

- `id`: number (PK)
- `name`: string

**Relaciones:**

- `OneToMany` con `Container`
- `OneToMany` con `Lab`

---

## Diagrama Entidad-RelaciÃ³n

```mermaid
erDiagram
    User ||--o{ Container : "owns"
    User ||--o{ Lab : "enrolls_in"
    User ||--|| Role : "has"

    Lab ||--|| Status : "has_status"
    Lab ||--o{ Category : "belongs_to"
    Lab ||--|| Difficulty : "has_difficulty"
    Lab ||--|| OperatingSystem : "runs_on"
    Lab ||--o{ Container : "has_instances"

    Container ||--|| Image : "uses"
    Container ||--|| Lab : "belongs_to"
    Container ||--|| Status : "has_status"
    Container ||--|| User : "assigned_to"

    Image ||--|| OperatingSystem : "based_on"

    OperatingSystem ||--o{ Lab : "supports"
    OperatingSystem ||--o{ Image : "base_of"

    Category ||--o{ Lab : "categorizes"
    Difficulty ||--o{ Lab : "classifies"
    Status ||--o{ Container : "defines"
    Status ||--o{ Lab : "defines"
    Role ||--o{ User : "assigned_to"

    User {
        int id PK
        string fullName
        string username
        string email
        string password
        string role
        timestamp created
        timestamp updated
    }

    Role {
        int id PK
        string name UK
    }

    Lab {
        string uuid PK
        string name
        string description
        float points
        int estimatedTime
        json tags
        timestamp created
        timestamp updated
    }

    Container {
        int id PK
        string name
        timestamp created
        timestamp lastActivity
    }

    Image {
        string id PK
        string name
        string version
        string repository
        timestamp created
        timestamp updated
    }

    OperatingSystem {
        int id PK
        string name
        timestamp created
        timestamp updated
    }

    Category {
        int id PK
        string name
    }

    Difficulty {
        int id PK
        string name
    }

    Status {
        int id PK
        string name
    }
```

---

## AnÃ¡lisis de Relaciones

### âœ… **Relaciones Correctas**

1. **User - Container** (ManyToMany): âœ… Correcta, permite que usuarios gestionen mÃºltiples contenedores
2. **User - Lab** (ManyToMany): âœ… Correcta, usuarios pueden inscribirse en mÃºltiples labs
3. **Lab - Status** (ManyToOne): âœ… Correcta
4. **Lab - Difficulty** (ManyToOne): âœ… Correcta
5. **Lab - OperatingSystem** (ManyToOne): âœ… Correcta
6. **Container - Lab** (ManyToOne): âœ… Correcta con CASCADE
7. **Container - User** (ManyToOne): âœ… Correcta
8. **Container - Image** (ManyToOne): âœ… Correcta

---

### âš ï¸ **Relaciones con Problemas**

#### 1. **User.role - DeberÃ­a ser relaciÃ³n con Role**

**Problema:**

```typescript
@Column({ nullable: true })
role: string; // admin, student, teacher
```

**DeberÃ­a ser:**

```typescript
@ManyToOne(() => Role, (role) => role.users)
@JoinColumn({ name: 'roleId' })
role: Role;
```

**RazÃ³n:** NormalizaciÃ³n de la base de datos y mejor control de roles.

---

#### 2. **Image - OperatingSystem (operatingSystem field)**

**Problema:**

```typescript
@OneToMany(() => OperatingSystem, (os) => os.id, { nullable: false })
@JoinColumn({ name: 'operatingSystemId' })
operatingSystem: OperatingSystem;
```

**DeberÃ­a ser:**

```typescript
@ManyToOne(() => OperatingSystem, (os) => os.images, { nullable: false })
@JoinColumn({ name: 'operatingSystemId' })
operatingSystem: OperatingSystem;
```

**RazÃ³n:** Una imagen tiene UN sistema operativo, no mÃºltiples. La relaciÃ³n inversa correcta es OneToMany.

---

#### 3. **Category - Lab (relaciÃ³n inconsistente)**

**En Category:**

```typescript
@OneToMany(() => Lab, (lab) => lab.categories, { nullable: true })
labs: Lab[];
```

**En Lab:**

```typescript
@ManyToMany(() => Category, (category) => category.labs, { nullable: true })
@JoinTable()
categories: Category[];
```

**Problema:** La definiciÃ³n es inconsistente. Si en Lab es `ManyToMany`, en Category tambiÃ©n debe serlo.

**SoluciÃ³n:** Cambiar en Category a:

```typescript
@ManyToMany(() => Lab, (lab) => lab.categories, { nullable: true })
categories: Lab[];
```

---

#### 4. **User - Container (ManyToMany vs ManyToOne)**

**Problema Conceptual:**

- En `User`: `ManyToMany` con `Container`
- En `Container`: `ManyToOne` con `User`

**AnÃ¡lisis:**

- Si un contenedor pertenece a UN solo usuario (ManyToOne en Container), entonces la relaciÃ³n deberÃ­a ser `OneToMany` desde User.
- Si varios usuarios pueden compartir un contenedor, entonces deberÃ­a ser `ManyToMany` en ambos lados.

**RecomendaciÃ³n:**
Para un sistema de laboratorios, lo mÃ¡s lÃ³gico es que **cada contenedor pertenezca a UN usuario** (instancia personal).

**Cambiar en User:**

```typescript
@OneToMany(() => Container, (container) => container.user)
containers: Container[];
```

---

### âŒ **Relaciones Faltantes**

#### 1. **Role - User (OneToMany)**

**Falta en Role.entity.ts:**

```typescript
@OneToMany(() => User, (user) => user.role)
users: User[];
```

---

#### 2. **User - Lab (Progress/Enrollment tracking)**

**Problema:** La relaciÃ³n actual `ManyToMany` entre User y Lab no guarda informaciÃ³n adicional como:

- Progreso del usuario en el laboratorio
- Fecha de inscripciÃ³n
- CalificaciÃ³n obtenida
- Estado de completado

**RecomendaciÃ³n:** Crear una entidad intermedia `UserLabEnrollment`:

```typescript
@Entity()
export class UserLabEnrollment {
  @PrimaryGeneratedColumn()
  id: number;

  @ManyToOne(() => User, (user) => user.enrollments)
  user: User;

  @ManyToOne(() => Lab, (lab) => lab.enrollments)
  lab: Lab;

  @Column({ type: "float", default: 0 })
  progress: number; // Progreso 0-100%

  @Column({ type: "float", nullable: true })
  score: number; // CalificaciÃ³n obtenida

  @Column({ type: "boolean", default: false })
  completed: boolean;

  @Column({ type: "timestamp", default: () => "CURRENT_TIMESTAMP" })
  enrolledAt: Date;

  @Column({ type: "timestamp", nullable: true })
  completedAt: Date;
}
```

---

#### 3. **Lab - Flag/Challenge (Objetivos del laboratorio)**

**Falta:** Una entidad para representar los desafÃ­os/flags dentro de cada laboratorio.

```typescript
@Entity()
export class Challenge {
  @PrimaryGeneratedColumn()
  id: number;

  @ManyToOne(() => Lab, (lab) => lab.challenges)
  lab: Lab;

  @Column({ type: "varchar", length: 255 })
  title: string;

  @Column({ type: "text" })
  description: string;

  @Column({ type: "varchar", length: 255 })
  flagValue: string; // Hash de la flag

  @Column({ type: "float" })
  points: number;

  @Column({ type: "int" })
  order: number; // Orden del desafÃ­o
}
```

---

#### 4. **User - Challenge (Submissions/Flags capturadas)**

```typescript
@Entity()
export class FlagSubmission {
  @PrimaryGeneratedColumn()
  id: number;

  @ManyToOne(() => User, (user) => user.submissions)
  user: User;

  @ManyToOne(() => Challenge, (challenge) => challenge.submissions)
  challenge: Challenge;

  @Column({ type: "varchar", length: 255 })
  submittedFlag: string;

  @Column({ type: "boolean" })
  isCorrect: boolean;

  @Column({ type: "timestamp", default: () => "CURRENT_TIMESTAMP" })
  submittedAt: Date;
}
```

---

### ğŸ”„ **Relaciones que Sobran o son Redundantes**

#### 1. **Status.labs con JoinColumn incorrecto**

En `Status.entity.ts`:

```typescript
@OneToMany(() => Lab, (lab) => lab.uuid, { nullable: true })
@JoinColumn({ name: 'labId' })
labs: Lab[];
```

**Problema:**

- En relaciones `OneToMany`, el `@JoinColumn` va en el lado `ManyToOne` (Lab), no en el lado `OneToMany` (Status)
- AdemÃ¡s, la relaciÃ³n apunta a `lab.uuid` en vez de `lab.status`

**CorrecciÃ³n:**

```typescript
@OneToMany(() => Lab, (lab) => lab.status, { nullable: true })
labs: Lab[];
```

---

## Casos de Uso

### CU-01: Registro de Usuario

**Actor:** Usuario no registrado

**Precondiciones:** Ninguna

**Flujo Principal:**

1. El usuario accede a la pÃ¡gina de registro
2. El usuario ingresa: username, email, password
3. El sistema valida los datos (email Ãºnico, formato correcto)
4. El sistema hashea la contraseÃ±a
5. El sistema crea el usuario con rol "student" por defecto
6. El sistema envÃ­a confirmaciÃ³n de registro

**Postcondiciones:** Usuario creado en la base de datos

**Flujos Alternativos:**

- **FA1:** Email ya existe â†’ Mostrar error "Email already registered"
- **FA2:** ContraseÃ±a dÃ©bil â†’ Mostrar requisitos de contraseÃ±a

---

### CU-02: Inicio de SesiÃ³n

**Actor:** Usuario registrado

**Precondiciones:** Usuario debe estar registrado

**Flujo Principal:**

1. El usuario accede a la pÃ¡gina de login
2. El usuario ingresa email y password
3. El sistema valida las credenciales
4. El sistema genera un JWT token
5. El sistema establece una cookie HttpOnly con el token
6. El sistema redirige al dashboard segÃºn el rol

**Postcondiciones:** Usuario autenticado con sesiÃ³n activa

**Flujos Alternativos:**

- **FA1:** Credenciales incorrectas â†’ Mostrar "Invalid credentials"
- **FA2:** Usuario no existe â†’ Mostrar "Invalid credentials"

---

### CU-03: Listar Laboratorios Disponibles

**Actor:** Usuario autenticado

**Precondiciones:** Usuario debe estar autenticado

**Flujo Principal:**

1. El usuario accede a la secciÃ³n de laboratorios
2. El sistema obtiene todos los labs con estado "Active"
3. El sistema carga las relaciones: category, difficulty, OS, status
4. El sistema muestra los laboratorios con filtros

**Postcondiciones:** Listado de laboratorios visualizado

**Filtros disponibles:**

- Por categorÃ­a
- Por dificultad
- Por sistema operativo
- Por tags

---

### CU-04: Crear Laboratorio (Admin/Teacher)

**Actor:** Administrador o Profesor

**Precondiciones:**

- Usuario debe tener rol "admin" o "teacher"
- Debe estar autenticado

**Flujo Principal:**

1. El usuario accede a "Crear Laboratorio"
2. El usuario ingresa:
   - Nombre
   - DescripciÃ³n
   - Puntos
   - Tiempo estimado
   - Tags
   - CategorÃ­as (mÃºltiples)
   - Dificultad
   - Sistema Operativo
   - Estado inicial
3. El sistema valida los datos
4. El sistema genera un UUID para el laboratorio
5. El sistema crea el laboratorio
6. El sistema crea los desafÃ­os asociados (si aplica)

**Postcondiciones:** Laboratorio creado y disponible

---

### CU-05: Inscribirse en un Laboratorio

**Actor:** Estudiante

**Precondiciones:**

- Usuario con rol "student"
- Laboratorio debe estar activo
- Usuario no debe estar inscrito previamente

**Flujo Principal:**

1. El usuario visualiza los detalles del laboratorio
2. El usuario hace clic en "Inscribirse"
3. El sistema verifica que el usuario no estÃ© inscrito
4. El sistema crea la relaciÃ³n User-Lab
5. El sistema muestra confirmaciÃ³n

**Postcondiciones:** Usuario inscrito en el laboratorio

---

### CU-06: Iniciar Contenedor de Laboratorio

**Actor:** Estudiante inscrito

**Precondiciones:**

- Usuario inscrito en el laboratorio
- No debe tener un contenedor activo del mismo laboratorio

**Flujo Principal:**

1. El usuario hace clic en "Iniciar Laboratorio"
2. El sistema verifica que la imagen Docker existe
3. El sistema crea un contenedor Docker usando `DockerService`
4. El sistema registra el contenedor en la base de datos:
   - Asocia con el laboratorio
   - Asocia con el usuario
   - Establece estado "running"
   - Guarda la imagen utilizada
5. El sistema inicia el contenedor
6. El sistema devuelve informaciÃ³n de acceso (IP, puerto, credenciales)

**Postcondiciones:**

- Contenedor Docker en ejecuciÃ³n
- Registro en base de datos creado

**Flujos Alternativos:**

- **FA1:** Imagen no existe â†’ Descargar imagen primero
- **FA2:** Error al crear contenedor â†’ Mostrar error y registrar log

---

### CU-07: Detener Contenedor

**Actor:** Usuario o Sistema (timeout)

**Precondiciones:** Contenedor debe estar en estado "running"

**Flujo Principal:**

1. El usuario hace clic en "Detener Laboratorio"
2. El sistema obtiene el ID del contenedor Docker
3. El sistema llama a `DockerService.stopContainer()`
4. El sistema actualiza el estado a "stopped"
5. El sistema actualiza `lastActivity`

**Postcondiciones:** Contenedor detenido

---

### CU-08: Eliminar Contenedor

**Actor:** Usuario o Sistema (limpieza)

**Precondiciones:** Contenedor debe estar detenido

**Flujo Principal:**

1. El usuario o sistema solicita eliminar el contenedor
2. El sistema detiene el contenedor si estÃ¡ activo
3. El sistema llama a `DockerService.removeContainer()`
4. El sistema elimina el registro de la base de datos

**Postcondiciones:** Contenedor eliminado completamente

---

### CU-09: Enviar Flag (Resolver DesafÃ­o)

**Actor:** Estudiante

**Precondiciones:**

- Usuario inscrito en el laboratorio
- Contenedor activo

**Flujo Principal:**

1. El usuario encuentra una flag en el contenedor
2. El usuario ingresa la flag en la interfaz
3. El sistema valida la flag contra el hash almacenado
4. El sistema registra la submission
5. Si es correcta:
   - Suma los puntos al usuario
   - Marca el desafÃ­o como completado
   - Actualiza el progreso del laboratorio
6. El sistema muestra feedback

**Postcondiciones:**

- DesafÃ­o marcado como resuelto (si es correcto)
- Puntos sumados al usuario

---

### CU-10: Ver Progreso del Laboratorio

**Actor:** Estudiante

**Precondiciones:** Usuario inscrito en el laboratorio

**Flujo Principal:**

1. El usuario accede a "Mis Laboratorios"
2. El sistema obtiene los enrollments del usuario
3. El sistema calcula el progreso:
   - DesafÃ­os completados / Total de desafÃ­os
   - Tiempo transcurrido
   - Puntos obtenidos
4. El sistema muestra el progreso

**Postcondiciones:** InformaciÃ³n de progreso visualizada

---

### CU-11: Gestionar CategorÃ­as (Admin)

**Actor:** Administrador

**Precondiciones:** Usuario con rol "admin"

**Flujo Principal:**

1. El admin accede a "Gestionar CategorÃ­as"
2. El sistema muestra todas las categorÃ­as
3. El admin puede:
   - Crear nueva categorÃ­a
   - Editar categorÃ­a existente
   - Eliminar categorÃ­a (si no tiene labs asociados)

**Postcondiciones:** CatÃ¡logo de categorÃ­as actualizado

---

### CU-12: Gestionar Dificultades (Admin)

**Actor:** Administrador

**Precondiciones:** Usuario con rol "admin"

**Flujo Principal:**

1. El admin accede a "Gestionar Dificultades"
2. El sistema muestra todas las dificultades
3. El admin puede:
   - Crear nueva dificultad
   - Editar dificultad existente
   - Eliminar dificultad (si no tiene labs asociados)

**Postcondiciones:** CatÃ¡logo de dificultades actualizado

---

### CU-13: Monitorear Contenedores Activos (Admin)

**Actor:** Administrador

**Precondiciones:** Usuario con rol "admin"

**Flujo Principal:**

1. El admin accede a "Monitoreo de Contenedores"
2. El sistema lista todos los contenedores activos
3. Para cada contenedor muestra:
   - Usuario propietario
   - Laboratorio asociado
   - Estado
   - Tiempo de actividad
   - Uso de recursos
4. El admin puede:
   - Detener contenedores
   - Ver logs
   - Eliminar contenedores

**Postcondiciones:** Vista de monitoreo actualizada

---

### CU-14: Seeder de Base de Datos (Admin/Dev)

**Actor:** Administrador o Desarrollador

**Precondiciones:** Base de datos debe estar vacÃ­a o en modo desarrollo

**Flujo Principal:**

1. El usuario ejecuta el endpoint `/seed` o comando de seeder
2. El sistema crea datos de prueba:
   - Roles (admin, teacher, student)
   - Usuarios de prueba
   - CategorÃ­as
   - Dificultades
   - Sistemas operativos
   - Estados
   - Laboratorios de ejemplo
   - ImÃ¡genes Docker

**Postcondiciones:** Base de datos poblada con datos de prueba

---

## Diagramas UML

### Diagrama de Clases (Modelo de Dominio)

```mermaid
classDiagram
    class User {
        +int id
        +string fullName
        +string username
        +string email
        +string password
        +timestamp created
        +timestamp updated
        +login()
        +register()
        +enrollInLab()
        +startContainer()
        +submitFlag()
    }

    class Role {
        +int id
        +string name
    }

    class Lab {
        +string uuid
        +string name
        +string description
        +float points
        +int estimatedTime
        +string[] tags
        +timestamp created
        +timestamp updated
        +addChallenge()
        +updateStatus()
    }

    class Container {
        +int id
        +string name
        +timestamp created
        +timestamp lastActivity
        +start()
        +stop()
        +remove()
        +inspect()
    }

    class Image {
        +string id
        +string name
        +string version
        +string repository
        +timestamp created
        +timestamp updated
        +pull()
    }

    class OperatingSystem {
        +int id
        +string name
        +timestamp created
        +timestamp updated
    }

    class Category {
        +int id
        +string name
        +addLab()
        +removeLab()
    }

    class Difficulty {
        +int id
        +string name
    }

    class Status {
        +int id
        +string name
    }

    class UserLabEnrollment {
        +int id
        +float progress
        +float score
        +boolean completed
        +timestamp enrolledAt
        +timestamp completedAt
        +updateProgress()
    }

    class Challenge {
        +int id
        +string title
        +string description
        +string flagValue
        +float points
        +int order
        +validateFlag()
    }

    class FlagSubmission {
        +int id
        +string submittedFlag
        +boolean isCorrect
        +timestamp submittedAt
        +validate()
    }

    User "1" --> "1" Role : has
    User "1" --> "*" Container : owns
    User "1" --> "*" UserLabEnrollment : has
    User "1" --> "*" FlagSubmission : submits

    Lab "1" --> "*" UserLabEnrollment : has
    Lab "1" --> "1" Status : has
    Lab "*" --> "*" Category : belongs to
    Lab "1" --> "1" Difficulty : has
    Lab "1" --> "1" OperatingSystem : runs on
    Lab "1" --> "*" Container : spawns
    Lab "1" --> "*" Challenge : contains

    Container "1" --> "1" Image : uses
    Container "1" --> "1" Lab : instance of
    Container "1" --> "1" Status : has
    Container "1" --> "1" User : belongs to

    Image "1" --> "1" OperatingSystem : based on

    Challenge "1" --> "*" FlagSubmission : receives
    Challenge "1" --> "1" Lab : belongs to

    FlagSubmission "1" --> "1" User : from
    FlagSubmission "1" --> "1" Challenge : for
```

---

### Diagrama de Secuencia: Inicio de Laboratorio

```mermaid
sequenceDiagram
    actor User as Usuario
    participant Frontend
    participant Backend as Backend API
    participant ContainerService
    participant DockerService
    participant Database
    participant Docker

    User->>Frontend: Click "Iniciar Laboratorio"
    Frontend->>Backend: POST /containers/start/:labId
    Backend->>Database: Verificar inscripciÃ³n del usuario
    Database-->>Backend: Usuario inscrito âœ“

    Backend->>Database: Obtener informaciÃ³n del Lab
    Database-->>Backend: Lab details + Image info

    Backend->>DockerService: pullImageIfNotExists(imageName)
    DockerService->>Docker: Check if image exists locally

    alt Image no existe localmente
        Docker-->>DockerService: Image not found
        DockerService->>Docker: docker pull imageName
        Docker-->>DockerService: Image pulled successfully
    else Image existe
        Docker-->>DockerService: Image exists
    end

    Backend->>DockerService: createContainer(imageName, containerName)
    DockerService->>Docker: docker create --name containerName imageName
    Docker-->>DockerService: Container created (container_id)

    Backend->>DockerService: startContainer(containerName)
    DockerService->>Docker: docker start containerName
    Docker-->>DockerService: Container started

    Backend->>Database: Crear registro Container
    Database-->>Backend: Container saved

    Backend->>DockerService: inspectContainer(containerName)
    DockerService->>Docker: docker inspect containerName
    Docker-->>DockerService: Container info (IP, ports, etc.)

    Backend-->>Frontend: { containerId, accessInfo: { ip, port } }
    Frontend-->>User: Mostrar informaciÃ³n de acceso
```

---

### Diagrama de Secuencia: EnvÃ­o de Flag

```mermaid
sequenceDiagram
    actor User as Usuario
    participant Frontend
    participant Backend as Backend API
    participant ChallengeService
    participant Database
    participant ScoreService

    User->>Frontend: Ingresa flag encontrada
    Frontend->>Backend: POST /challenges/:challengeId/submit
    Backend->>Database: Obtener Challenge
    Database-->>Backend: Challenge details (flagValue hash)

    Backend->>ChallengeService: validateFlag(submittedFlag, storedHash)
    ChallengeService->>ChallengeService: Hash(submittedFlag)
    ChallengeService->>ChallengeService: Compare hashes

    alt Flag correcta
        ChallengeService-->>Backend: isCorrect = true
        Backend->>Database: Crear FlagSubmission (isCorrect: true)
        Backend->>Database: Actualizar UserLabEnrollment.progress
        Backend->>ScoreService: addPoints(userId, points)
        ScoreService->>Database: Actualizar User.totalPoints
        Database-->>Backend: Updated
        Backend-->>Frontend: { success: true, points: 50, message: "Correct!" }
        Frontend-->>User: ğŸ‰ "Â¡Correcto! +50 puntos"
    else Flag incorrecta
        ChallengeService-->>Backend: isCorrect = false
        Backend->>Database: Crear FlagSubmission (isCorrect: false)
        Database-->>Backend: Saved
        Backend-->>Frontend: { success: false, message: "Incorrect flag" }
        Frontend-->>User: âŒ "Flag incorrecta, intenta de nuevo"
    end
```

---

### Diagrama de Actividades: Flujo de un Estudiante

```mermaid
flowchart TD
    Start([Inicio]) --> Login{Â¿EstÃ¡<br/>autenticado?}
    Login -->|No| LoginPage[Ir a Login]
    LoginPage --> AuthCheck{Â¿Credenciales<br/>vÃ¡lidas?}
    AuthCheck -->|No| LoginPage
    AuthCheck -->|SÃ­| Dashboard
    Login -->|SÃ­| Dashboard[Dashboard]

    Dashboard --> ViewLabs[Ver Laboratorios Disponibles]
    ViewLabs --> FilterLabs{Filtrar por<br/>categorÃ­a/dificultad}
    FilterLabs --> SelectLab[Seleccionar Laboratorio]

    SelectLab --> CheckEnrolled{Â¿Ya estÃ¡<br/>inscrito?}
    CheckEnrolled -->|No| Enroll[Inscribirse en Lab]
    Enroll --> StartLab
    CheckEnrolled -->|SÃ­| StartLab{Â¿Iniciar<br/>contenedor?}

    StartLab -->|SÃ­| CreateContainer[Sistema crea contenedor]
    CreateContainer --> PullImage{Â¿Imagen<br/>existe?}
    PullImage -->|No| DownloadImage[Descargar imagen]
    DownloadImage --> StartContainer
    PullImage -->|SÃ­| StartContainer[Iniciar contenedor]

    StartContainer --> ShowAccess[Mostrar info de acceso]
    ShowAccess --> WorkOnLab[Trabajar en el laboratorio]

    WorkOnLab --> FoundFlag{Â¿EncontrÃ³<br/>una flag?}
    FoundFlag -->|SÃ­| SubmitFlag[Enviar flag]
    SubmitFlag --> ValidateFlag{Â¿Flag<br/>correcta?}
    ValidateFlag -->|SÃ­| AddPoints[Sumar puntos]
    AddPoints --> UpdateProgress[Actualizar progreso]
    UpdateProgress --> CheckComplete{Â¿Lab<br/>completado?}
    CheckComplete -->|No| WorkOnLab
    CheckComplete -->|SÃ­| MarkComplete[Marcar como completado]
    MarkComplete --> Certificate[Generar certificado]
    Certificate --> End([Fin])

    ValidateFlag -->|No| TryAgain[Intentar nuevamente]
    TryAgain --> WorkOnLab

    FoundFlag -->|No| Continue{Â¿Continuar?}
    Continue -->|SÃ­| WorkOnLab
    Continue -->|No| StopContainer[Detener contenedor]
    StopContainer --> End
```

---

### Diagrama de Componentes

```mermaid
graph TB
    subgraph "Frontend - Next.js"
        UI[UI Components]
        Pages[Pages/Routes]
        API_Client[API Client lib/api.ts]
        Auth[useAuth Hook]
    end

    subgraph "Backend - NestJS"
        AuthModule[Auth Module]
        LabsModule[Labs Module]
        ContainerModule[Container Module]
        DockerModule[Docker Module]
        UsersModule[Users Module]
        CategoriesModule[Categories Module]
        DifficultyModule[Difficulty Module]
        ImagesModule[Images Module]
        StatusModule[Status Module]
        OSModule[OS Module]
    end

    subgraph "Servicios Externos"
        Docker[Docker Engine]
        PostgreSQL[(PostgreSQL DB)]
    end

    UI --> Pages
    Pages --> API_Client
    API_Client --> Auth

    API_Client -->|REST API| AuthModule
    API_Client -->|REST API| LabsModule
    API_Client -->|REST API| ContainerModule

    AuthModule --> UsersModule
    LabsModule --> CategoriesModule
    LabsModule --> DifficultyModule
    LabsModule --> OSModule
    LabsModule --> StatusModule

    ContainerModule --> DockerModule
    ContainerModule --> ImagesModule
    ContainerModule --> LabsModule
    ContainerModule --> UsersModule

    DockerModule -->|Docker API| Docker

    AuthModule --> PostgreSQL
    LabsModule --> PostgreSQL
    ContainerModule --> PostgreSQL
    UsersModule --> PostgreSQL
    CategoriesModule --> PostgreSQL
    DifficultyModule --> PostgreSQL
    ImagesModule --> PostgreSQL
    StatusModule --> PostgreSQL
    OSModule --> PostgreSQL
```

---

## Recomendaciones y Mejoras

### ğŸ”§ **1. Correcciones CrÃ­ticas en Entidades**

#### User.entity.ts

```typescript
// Cambiar de:
@Column({ nullable: true })
role: string;

// A:
@ManyToOne(() => Role, (role) => role.users, { nullable: false })
@JoinColumn({ name: 'roleId' })
role: Role;

// Y cambiar la relaciÃ³n con Container:
// De ManyToMany a OneToMany
@OneToMany(() => Container, (container) => container.user)
containers: Container[];
```

#### Role.entity.ts

```typescript
// Agregar:
@OneToMany(() => User, (user) => user.role)
users: User[];
```

#### Category.entity.ts

```typescript
// Cambiar de OneToMany a ManyToMany:
@ManyToMany(() => Lab, (lab) => lab.categories, { nullable: true })
categories: Lab[];
```

#### Image.entity.ts

```typescript
// Corregir la relaciÃ³n operatingSystem:
// De:
@OneToMany(() => OperatingSystem, (os) => os.id, { nullable: false })
@JoinColumn({ name: 'operatingSystemId' })
operatingSystem: OperatingSystem;

// A:
@ManyToOne(() => OperatingSystem, (os) => os.images, { nullable: false })
@JoinColumn({ name: 'operatingSystemId' })
operatingSystem: OperatingSystem;
```

#### Status.entity.ts

```typescript
// Corregir:
@OneToMany(() => Lab, (lab) => lab.status, { nullable: true })
labs: Lab[];
```

---

### ğŸ†• **2. Nuevas Entidades Recomendadas**

#### UserLabEnrollment.entity.ts (IMPORTANTE)

```typescript
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  ManyToOne,
  JoinColumn,
} from "typeorm";
import { User } from "../users/user.entity";
import { Lab } from "../labs/lab.entity";

@Entity()
export class UserLabEnrollment {
  @PrimaryGeneratedColumn()
  id: number;

  @ManyToOne(() => User, (user) => user.enrollments, { nullable: false })
  @JoinColumn({ name: "userId" })
  user: User;

  @ManyToOne(() => Lab, (lab) => lab.enrollments, { nullable: false })
  @JoinColumn({ name: "labId" })
  lab: Lab;

  @Column({ type: "float", default: 0.0 })
  progress: number; // 0.0 a 100.0

  @Column({ type: "float", nullable: true })
  score: number;

  @Column({ type: "boolean", default: false })
  completed: boolean;

  @Column({ type: "timestamp", default: () => "CURRENT_TIMESTAMP" })
  enrolledAt: Date;

  @Column({ type: "timestamp", nullable: true })
  completedAt: Date;

  @Column({ type: "int", default: 0 })
  attemptsCount: number;

  @Column({ type: "int", default: 0 })
  hintsUsed: number;
}
```

#### Challenge.entity.ts

```typescript
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  ManyToOne,
  OneToMany,
  JoinColumn,
} from "typeorm";
import { Lab } from "../labs/lab.entity";
import { FlagSubmission } from "./flag-submission.entity";

@Entity()
export class Challenge {
  @PrimaryGeneratedColumn()
  id: number;

  @ManyToOne(() => Lab, (lab) => lab.challenges, { nullable: false })
  @JoinColumn({ name: "labId" })
  lab: Lab;

  @Column({ type: "varchar", length: 255, nullable: false })
  title: string;

  @Column({ type: "text", nullable: false })
  description: string;

  @Column({ type: "varchar", length: 255, nullable: false })
  flagValue: string; // Almacenar como hash (bcrypt o SHA256)

  @Column({ type: "float", default: 0 })
  points: number;

  @Column({ type: "int", nullable: false })
  order: number; // Orden del desafÃ­o en el lab

  @Column({ type: "text", nullable: true })
  hint: string;

  @Column({ type: "boolean", default: true })
  isActive: boolean;

  @OneToMany(() => FlagSubmission, (submission) => submission.challenge)
  submissions: FlagSubmission[];

  @Column({ type: "timestamp", default: () => "CURRENT_TIMESTAMP" })
  created: Date;
}
```

#### FlagSubmission.entity.ts

```typescript
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  ManyToOne,
  JoinColumn,
} from "typeorm";
import { User } from "../users/user.entity";
import { Challenge } from "./challenge.entity";

@Entity()
export class FlagSubmission {
  @PrimaryGeneratedColumn()
  id: number;

  @ManyToOne(() => User, (user) => user.flagSubmissions, { nullable: false })
  @JoinColumn({ name: "userId" })
  user: User;

  @ManyToOne(() => Challenge, (challenge) => challenge.submissions, {
    nullable: false,
  })
  @JoinColumn({ name: "challengeId" })
  challenge: Challenge;

  @Column({ type: "varchar", length: 255, nullable: false })
  submittedFlag: string; // No almacenar en texto plano en producciÃ³n

  @Column({ type: "boolean", nullable: false })
  isCorrect: boolean;

  @Column({ type: "varchar", length: 45, nullable: true })
  ipAddress: string;

  @Column({ type: "timestamp", default: () => "CURRENT_TIMESTAMP" })
  submittedAt: Date;
}
```

---

### ğŸ“Š **3. Mejoras en el Modelo de Negocio**

#### Agregar a User.entity.ts:

```typescript
@Column({ type: 'int', default: 0 })
totalPoints: number;

@Column({ type: 'int', default: 0 })
labsCompleted: number;

@Column({ type: 'varchar', length: 50, nullable: true })
avatarUrl: string;

@Column({ type: 'text', nullable: true })
bio: string;

@OneToMany(() => UserLabEnrollment, (enrollment) => enrollment.user)
enrollments: UserLabEnrollment[];

@OneToMany(() => FlagSubmission, (submission) => submission.user)
flagSubmissions: FlagSubmission[];
```

#### Agregar a Lab.entity.ts:

```typescript
@Column({ type: 'text', nullable: true })
objectives: string; // Objetivos del laboratorio

@Column({ type: 'text', nullable: true })
prerequisites: string; // Conocimientos previos requeridos

@Column({ type: 'int', default: 0 })
enrollmentCount: number; // Contador de inscripciones

@Column({ type: 'int', default: 0 })
completionCount: number; // Contador de completados

@Column({ type: 'float', default: 0 })
averageRating: number; // Rating promedio

@Column({ type: 'boolean', default: true })
isPublished: boolean; // Lab pÃºblico o en draft

@OneToMany(() => UserLabEnrollment, (enrollment) => enrollment.lab)
enrollments: UserLabEnrollment[];

@OneToMany(() => Challenge, (challenge) => challenge.lab)
challenges: Challenge[];
```

---

### ğŸ” **4. Mejoras de Seguridad**

1. **Agregar Ã­ndices para consultas frecuentes:**

```typescript
// En User.entity.ts
@Index('idx_user_email')
@Column()
email: string;

// En Lab.entity.ts
@Index('idx_lab_status')
@ManyToOne(() => Status, (status) => status.labs)
status: Status;
```

2. **Agregar soft deletes:**

```typescript
@Column({ type: 'timestamp', nullable: true })
deletedAt: Date;
```

3. **Validaciones adicionales:**

- Email Ãºnico en User
- Username Ãºnico en User
- ValidaciÃ³n de puertos disponibles antes de crear contenedores
- LÃ­mite de contenedores activos por usuario

---

### ğŸ“ˆ **5. Funcionalidades Adicionales Sugeridas**

1. **Sistema de Ratings/Reviews**

```typescript
@Entity()
export class LabReview {
  @PrimaryGeneratedColumn()
  id: number;

  @ManyToOne(() => User, { nullable: false })
  user: User;

  @ManyToOne(() => Lab, { nullable: false })
  lab: Lab;

  @Column({ type: "int" })
  rating: number; // 1-5

  @Column({ type: "text", nullable: true })
  comment: string;

  @Column({ type: "timestamp", default: () => "CURRENT_TIMESTAMP" })
  created: Date;
}
```

2. **Sistema de Notificaciones**

```typescript
@Entity()
export class Notification {
  @PrimaryGeneratedColumn()
  id: number;

  @ManyToOne(() => User, { nullable: false })
  user: User;

  @Column({ type: "varchar", length: 255 })
  title: string;

  @Column({ type: "text" })
  message: string;

  @Column({ type: "boolean", default: false })
  isRead: boolean;

  @Column({ type: "timestamp", default: () => "CURRENT_TIMESTAMP" })
  created: Date;
}
```

3. **Logs de Actividad**

```typescript
@Entity()
export class ActivityLog {
  @PrimaryGeneratedColumn()
  id: number;

  @ManyToOne(() => User)
  user: User;

  @Column({ type: "varchar", length: 100 })
  action: string; // "container_started", "flag_submitted", etc.

  @Column({ type: "varchar", length: 255, nullable: true })
  entityType: string; // "Lab", "Container", etc.

  @Column({ type: "int", nullable: true })
  entityId: number;

  @Column({ type: "varchar", length: 45, nullable: true })
  ipAddress: string;

  @Column({ type: "timestamp", default: () => "CURRENT_TIMESTAMP" })
  created: Date;
}
```

---

### ğŸ¯ **6. Optimizaciones de Rendimiento**

1. **Eager/Lazy Loading estratÃ©gico:**

```typescript
// En Lab.entity.ts - cargar siempre las relaciones principales
@ManyToOne(() => Status, (status) => status.labs, { eager: true })
status: Status;

@ManyToOne(() => Difficulty, (difficulty) => difficulty.labs, { eager: true })
difficulty: Difficulty;
```

2. **PaginaciÃ³n en listados:**

```typescript
// En lab.service.ts
async getAllLabs(page: number = 1, limit: number = 20) {
  return await this.labRepository.find({
    skip: (page - 1) * limit,
    take: limit,
    relations: ['status', 'difficulty', 'categories', 'operatingSystem']
  });
}
```

3. **CachÃ© de consultas frecuentes:**

- Usar Redis para cachear listados de labs
- Cachear informaciÃ³n de imÃ¡genes Docker disponibles

---

### ğŸ“ **7. DTOs Recomendados**

```typescript
// CreateLabDto
export class CreateLabDto {
  @IsString()
  name: string;

  @IsString()
  description: string;

  @IsNumber()
  points: number;

  @IsNumber()
  estimatedTime: number;

  @IsArray()
  @IsString({ each: true })
  tags: string[];

  @IsNumber()
  statusId: number;

  @IsArray()
  @IsNumber({}, { each: true })
  categoryIds: number[];

  @IsNumber()
  difficultyId: number;

  @IsNumber()
  operatingSystemId: number;

  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => CreateChallengeDto)
  challenges: CreateChallengeDto[];
}

// CreateChallengeDto
export class CreateChallengeDto {
  @IsString()
  title: string;

  @IsString()
  description: string;

  @IsString()
  flagValue: string;

  @IsNumber()
  points: number;

  @IsNumber()
  order: number;
}

// SubmitFlagDto
export class SubmitFlagDto {
  @IsNumber()
  challengeId: number;

  @IsString()
  flag: string;
}

// EnrollLabDto
export class EnrollLabDto {
  @IsString()
  labUuid: string;
}
```

---

## Resumen de Cambios CrÃ­ticos

### âœ… **Cambios Obligatorios:**

1. **User.role**: Cambiar de `string` a relaciÃ³n `ManyToOne` con `Role`
2. **Image.operatingSystem**: Cambiar de `OneToMany` a `ManyToOne`
3. **Category-Lab**: Consistencia en relaciÃ³n `ManyToMany`
4. **User-Container**: Cambiar de `ManyToMany` a `OneToMany`
5. **Status.labs**: Corregir definiciÃ³n de relaciÃ³n
6. **Role**: Agregar relaciÃ³n `OneToMany` con `User`

### ğŸ†• **Entidades Nuevas Recomendadas:**

1. **UserLabEnrollment** - GestiÃ³n de inscripciones y progreso (CRÃTICO)
2. **Challenge** - DesafÃ­os dentro de laboratorios (IMPORTANTE)
3. **FlagSubmission** - Registro de intentos de flags (IMPORTANTE)
4. **LabReview** - Sistema de valoraciones (OPCIONAL)
5. **Notification** - Notificaciones a usuarios (OPCIONAL)
6. **ActivityLog** - AuditorÃ­a de acciones (OPCIONAL)

---

## ConclusiÃ³n

El sistema CSI-CyberLab tiene una arquitectura sÃ³lida pero requiere ajustes importantes en el modelo de datos, especialmente:

1. **NormalizaciÃ³n de roles:** Pasar de string a entidad relacional
2. **CorrecciÃ³n de cardinalidades:** Varias relaciones estÃ¡n mal definidas
3. **Tracking de progreso:** Falta entidad intermedia para User-Lab
4. **Sistema de desafÃ­os:** No existe entidad para flags/challenges dentro de labs
5. **AuditorÃ­a:** Falta logging de actividades

Con estas mejoras, el sistema tendrÃ¡:

- âœ… Mejor integridad referencial
- âœ… Seguimiento completo del progreso del estudiante
- âœ… Sistema de gamificaciÃ³n robusto (puntos, flags, rankings)
- âœ… Trazabilidad de acciones
- âœ… Base escalable para nuevas funcionalidades

---

**Fecha de creaciÃ³n:** 12 de Diciembre de 2025  
**VersiÃ³n:** 1.0  
**Autor:** Sistema de DocumentaciÃ³n CSI-CyberLab
